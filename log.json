{
  "date": {
    "description": "Log by date",
    "children": {
      "20180414": {
        "description": "Preparing django ws backend in the same manner as the ui application. This will be used to serve the API to the react frontend.",
        "children": {
          "python dependencies": "django, channels, channels-redis, redis, asgi-redis",
          "models prepared": "DONE",
        }
      },
      "20180512": {
        "description": "Got basic api stuff working. Solving a couple problems with opening websockets",
        "children": {
          "R-1": {
            "description": "Multiple websockets being opened when reconnecting. Need to ensure that only one is.",
            "children": {
              "Look at how Websocket responds to events": "Added socket defined check when opening websocket."
            },
          },
          "R-4": {
            "description": "Move API and schema management to new APIManager",
            "children": {
              "Take code from MessageButton component": "Not very much, but the same calls need to be made in a more general form",
              "Struggling to think of a way to do queries properly": "The query must originate from a component, but the response must come back to it in some way, or at least, components should have a way of listening to the answers that they need.",
              "Flattening directory structure": "API and Websocket",
            }
          },
          "REMINDER: readystate": "It's likely I can do something more intelligent with the readystate of the websocket. I might have the opportunity to integrate this later, but it might not be necessary.",
        }
      },
      "20180513": {
        "description": "Shuffling some stuff around.",
        "children": {
          "API": "Moving to flat directory structure and adding withAPI HOC for components that need to access data.",
          "Models": "Thinking about models in their dual role as selector and action creator, since data needs to be funnelled in through the mapStateToProps function, but also fetched from the server.",
          "WebsocketManager": "Since the websocket is spawned from the API directly based on the protocol, it doesn't make much sense to have a WebsocketManager, so I am removing this.",
          "Websocket": "Combining reducers, etc for Websocket and WebsocketManager",

        }
      },
      "20180515": {
        "description": "Thinking about models and their dual role as selector and action creator.",
        "children": {
          "API saga": {
            "description": "Adding saga to convert websocket receive action into different api actions",
            "children": {

            }
          }
        }
      },
      "20180516": {
        "description": "I really like this API saga idea to split up the response from the websocket or even an http connection.",
        "children": {

        }
      },
      "20180519": {
        "description": "",
        "children": {

        }
      },
      "20180525": {
        "description": "Thinking about how data gets in and out of a component",
        "children": {
          "Out": "The only way for data to get out is to create an action and use dispatch. In a way, I think mapDispatchToProps is limiting since current props cannot be passed to a more complex method before dispatching the action. I would prefer simply calling the dispatch method on an action creator passed through mapStateToProps.",
          "API 'middleware'": "If a standard set of action creators are passed to the component, they can be passed from there to an instance of a general API class. These action creators will be simple low-level interactions with the API, rather than object specific actions. Once instantiated, the API object can spawn Model objects, and hence Instance objects of specific named classes from the schema. Calling a method on an Instance object such as .save() would dispatch an action containing the correct information.",
          "filtering": "Calling Model.filter(args) must do several things. Firstly, a request will go out to filter both the objects in the store and the server. These can be returned at different times, so must be referred to differently. Once new objects have been added to the store, there will be no way to tell which are the part of the group requested using the filter, unless the response that comes back contains a unique identifier for that specific filter combination."
        }
      },
      "20180529": {
        "description": "We've been working quite hard on the API connector to use with the withAPI component. The main breakthrough is the separation of senders and consumers. The senders do nothing other than set their own value for the consumers to incorporate into their packages that ultimately get sent to the server as a request.",
        "children": {

        }
      },
      "20180612": {
        "description": "Collecting my thoughts about how to do the schema properly with the request to the system and the output.",
        "children": {
          "schema": "The three inputs to the generation of a new schema are the mode of the schema, the models on the system, and the authorization available to the requesting identity. This should perhaps be generalised so that a request is always required to generate a schema, even if blank, and a response is always generated. In fact, the only meaningful representation of the schema should be the response, such that the response is simply a manifestation of a valid schema. In this design, the schema is a method that takes a response, system information, and models to yield a response. This implies that the schema is re-generated for inclusion in the response upon each request, or whenever an outgoing message is required.",
        }
      },
      "20180617": {
        "description": "Thinking more about the schema. I want to build it out of more formal objects to include options and errors.",
      },
      "20180630": {
        "description": "This schema might have the English language problem. I was trying to make a recursive format that would have the same behaviour at every level, but this appears to have more exceptions than rules.",
        "children": {
          "filter and instances": "The filter schema should receive an input describing how to filter the data, but should provide no output. The filter key should not even be visible in the output even if the mode is set to verbose. This behaviour is not controllable from within the schema, but must be judged from its parent, unless the way a schema renders itself is changed. Further, while input is sent to the filter schema, its values will affect the output of the instances schema. The instances output must contain every instance referred to during the query process, including instances from model methods, creation, and filtering. The model schema must act as a whole, since each part interacts with many others. They also must be done as a cascade, starting with filtering and creation and ending with the exclusion of certain attributes or relationships.",
          "models and references": "The original idea of references is that they could be used as a shorthand for a group of objects given as the output of a function or a filter. Perhaps create, filter, delete, paginate, and sort should be demoted to the level of any other model method. After all, their output is a set of model instances. In effect, a reference is generated for the output of any function, including deletion, since these values can be used to remove local storage.",
          "modes": "The mode was meant to control how the whole schema would present itself. There are several problems. The biggest is that the mode is both a value drawn from the input and a value that affects the output. This means it is not a matter of customisation, but is intrinsic to the schema. By rights it should sit outside the schema. The puppeteer is not part of the puppet. The alternative to this is to have a hard-coded declaration extracting the mode from the schema before it is processed, such that the mode will affect its own schema. It is strange, and opens the door to other hard-coded aspects of the schema which might not be appropriate. On a more practical note, the global mode should affect whether the description of a schema is shown, among other things. Is this true in all cases? Are there situations when the description should be shown even in a lower mode?",
          "respond method": {
            "description": "How many payloads can come through this door? Right off the bat, a distinction can be made between a value which is a JSON structure and one which is not. A single value cannot be recursive. The same set of questions can be asked at any level of the schema.",
            "children": {
              "questions": {
                "description": "A list of questions that is asked at any level of the schema",
                "children": {
                  "payload type": "Is the payload of the correct type? If not, it should be returned immediately with an error.",
                  "single valued payload": "If the payload has no children, it should execute its predefined query function and return the result.",
                  "invalid keys": "If the payload contains invalid child keys, it should return immediately with an error detailing the invalid keys",
                  "child responses": "The payload should be given to the children of the schema in some form, either divided by key, chained, or complete. Each child should return two things: whether it should be displayed at all, and the content of its response.",
                }
              }
            }
          },
          "null payload": "Maybe there don't have to be modes at all. If the payload is None, the response can just be the schema. This can apply to any level of the schema. If you want the schema for some part of the full schema, set its key to none. The mode of the schema can be included from the server side to say how the schem should be interpreted. A client application can be set up to received messages in different modes, for example the smallest could be a payload of raw data with no structure except an unique id and a blob of data. Database models could be used to mediate and prepare for this type of exchange.",
        }
      },
      "20180705": {
        "description": "Thinking about how to design the schema better now that I have made the recursive portion of it work for the query.",
        "children": {
          "Ways a schema can go": {
            "description": "A schema can take several forms, and there are paths through the schema taken by different use-cases.",
            "children": {
              "Schema is just a passthrough category": "The only errors this can produce is a unrecognised key or a type error. The default schema and response should account for this option, since it will be the most common.",
              "Schema collects a structure below it a yields a value": "",
            }
          }
        }
      },
      "20180706": {
        "description": "Continuing with the schema revision, splitting into different types",
        "children": {
          "implement chained variable model check": "The queries can be deconstructed individually and checked down through the chain of models without touching the database. This will allow the errors to apply specifically to a single query.",
        }
      },
      "20180707": {
        "description": "Thinking about model methods and their output",
        "children": {
          "model queries": "A query to a model should only yield instances of that model. This allow everything to stay confined to the correct branch of the tree. Is this correct? Can I have a method of a class that yields results from another class?",
        }
      },
      "20180715": {
        "description": "Working on instances schema. Quite tricky.",
        "children": {
          "instances schema": "The complication is difference between responding to an incoming instance with an id and a set of attributes and relationships specified, and trying to respond to a model instance that has already been fetched from the database. The correct way to do it is probably to divide the process into two sections, one of which is fetching from the database, such that the model instance can be returned instead of the call to the database.",
        }
      },
      "20180716": {
        "description": "Continuing with instances schema.",
        "children": {
          "instances": "My new idea is that the instances indexed schema should only be used for input. The reason is, the values of attributes, relationships, and instances methods should be accessed via model methods such as get and filter.",
        }
      }
    }
  },
  "entries": {
    "E0001": {
      "datetime": "2017-10-19:01-00",
      "comment": "Completed most of the backend except invitations and advertisements. Should be a quick addtion. Need to concentrate now on the front end structure. The auth app needs to cope with an admin creating an account to create a club. He will then bulk add users via an interface that will notify them via email. The users will then navigate to a link in that email with a key that uniquely identifies them against the record from the admin. Users will fill in their personal details and have the option to request roles within the club and to request to join other clubs. A user can also sign up directly and request to join clubs without an admin adding them via email.",
      "tasks": {
        "T0001": {
          "title": "Auth login view",
          "detail": "A standard login page for a user that has been activated.",
        },
        "T0002": {
          "title": "Activation view",
          "detail": "Activation page when creating user directly.",
        },
        "T0003": {
          "title": "Activation email view",
          "detail": "Activation page when creating user after being notified by email.",
        },
        "T0004": {
          "title": "Create user view",
          "detail": "Standard user signup view.",
        },
      },
    },
    "E0002": {
      "datetime": "2017-10-19:10-00",
      "comment": "Installing django-guardian and making some more backend changes before continuing. For example, invitations and advertisements need to be added.",
      "thoughts": {
        "P0001": {
          "title": "A realisation",
          "details": "django-guardian cannot give me role-based object permissions, only user-based. I have to check everything against the member. Will this slow me down?"
        },
        "P0002": {
          "title": "Role heirarchy?",
          "details": "Should you be able to place some roles over others in terms of permission?"
        },
        "P0003": {
          "title": "Asset heirarchy?",
          "details": "Nested asset relationships?"
        },
        "P0004": {
          "title": "Event heirarchy?",
          "details": "Nested event relationships?"
        },
      },
      "tasks": {
        "X0005": {
          "title": "Configure django-guardian and permissions",
          "detail": "Give each model that needs it appropriate permissions for use with DRF.",
        },
        "T0006": {
          "title": "Add invitations and advertisements",
          "detail": "Invitations should be from one club to another about an event_instance. Advertisements are role offers for members.",
        },
        "T0007": {
          "title": "Create user view",
          "detail": "Standard user signup view.",
        },
      },
    },
    "E0003": {
      "datetime": "2017-10-20:19-30",
      "comment": "I've had a cup of tea, so I'm all fired up. The API seems solid, but the most daunting thing is the frontend. Basically, for each 'resource', as in Clubs, Members, etc, there has to be a basic CRUD interface will embellishments that make them a bit more unique. I'm not sure I can make a single interface component that will cover everything, but there are some widely applicable components, such as a new list, with scroll bar and pagination.",
      "actions": {
        "A0001": {
          "title": "Adding assets",
          "detail": "Need to decide what components we need and what we need to update.",
        },
      },
    },
    "E0004": {
      "datetime": "2017-10-23:23-00",
      "comment": "State calling, animation, context, actions, models.js",
    }
  },
  "tasks": {
    "description": "A list of tasks that need completing",
    "children": {
      ""
    }
  }
}
